services:
  # Redis for shared state between Flask and Celery workers
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # RabbitMQ message broker for Celery
  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    ports:
      - "5672:5672"    # AMQP protocol port
      - "15672:15672"  # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Flask web server
  esphome-server:
    build: .
    image: esp-build-server
    ports:
      - "5001:5001"
    volumes:
      - esphome_jobs_data:/data/esphome_jobs
    environment:
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: rpc://
      REDIS_URL: redis://redis:6379/0
    depends_on:
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    restart: unless-stopped
    develop:
      watch:
        - path: ./app
          action: sync
          target: /app

  # Celery worker for processing compilation jobs
  celery-worker:
    build: .
    image: esp-build-server
    command: celery -A celery_worker.celery worker --loglevel=info --concurrency=2
    volumes:
      - esphome_jobs_data:/data/esphome_jobs
    environment:
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: rpc://
      REDIS_URL: redis://redis:6379/0
    depends_on:
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    restart: unless-stopped
    develop:
      watch:
        - path: ./app
          action: sync+restart
          target: /app


# This top-level key tells Docker to create and manage
# the named volume 'esphome_jobs_data'.
volumes:
  esphome_jobs_data: